var documenterSearchIndex = {"docs":
[{"location":"mbar/#MBAR-(Multistate-Bennett-acceptance-ratio)","page":"MBAR (Multistate Bennett acceptance ratio)","title":"MBAR (Multistate Bennett acceptance ratio)","text":"","category":"section"},{"location":"mbar/","page":"MBAR (Multistate Bennett acceptance ratio)","title":"MBAR (Multistate Bennett acceptance ratio)","text":"mbar(u_kl; ftol=1e-8, iterations=10^2)","category":"page"},{"location":"mbar/#MDToolbox.mbar-Tuple{Any}","page":"MBAR (Multistate Bennett acceptance ratio)","title":"MDToolbox.mbar","text":"mbar(u_kl; ftol=1e-8, iterations=10^2) -> F\n\nEstimates the free energy differences of umbrella-windowed systems by using the Multistate Bennet Acceptance Ratio Method (MBAR). Let K be # of umbrellas or different ensembles. u_kl is a K x K Array whose elements are reduced bias-factor or  potential energy of umbrella (or ensemble) simulation data k evaluated at umbrella (or ensemble) l. \n\nReturns (dimensionless) free energies of umbrella-windows or ensembles f_k. \n\nReferences\n\nM. R. Shirts and J. D. Chodera, J. Chem. Phys. 129, 124105 (2008).\n\n\n\n\n\n","category":"method"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/#Installation-of-the-package","page":"Installation","title":"Installation of the package","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Julia version 1.0 or later is required.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"]add https://github.com/matsunagalab/MDToolbox.jl.git\nusing MDToolbox","category":"page"},{"location":"installation/#Docker-image","page":"Installation","title":"Docker image","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Using the docker image, MDToolbox.jl can be readily used within REPL or Jupyter(Lab).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"## REPL\n$ docker run --rm -p 8888:8888 -e JUPYTER_ENABLE_LAB=yes -v \"$PWD\":/home/jovyan/work matsunagalab/mdtoolbox.jl julia\n\n## JupyterLab\n$ docker run --rm -p 8888:8888 -e JUPYTER_ENABLE_LAB=yes -v \"$PWD\":/home/jovyan/work matsunagalab/mdtoolbox.jl","category":"page"},{"location":"msm/#Makorv-state-models","page":"Makorv state models","title":"Makorv state models","text":"","category":"section"},{"location":"msm/","page":"Makorv state models","title":"Makorv state models","text":"msmgenerate(nframe::Int, T, pi_i)","category":"page"},{"location":"msm/#MDToolbox.msmgenerate-Tuple{Int64,Any,Any}","page":"Makorv state models","title":"MDToolbox.msmgenerate","text":"msmgenerate(nframe::Int, T, pi_i)\n            states = zeros(typeof(nframe), nframe)\n\nRandomly samples a state trajectory from the the given transition matrix, and equilibrium probabilities of states. \n\nExamples\n\njulia> T, pi_i = msmtransitionmatrix(C)\njulia> states = msmgenerate(1000, T, pi_i)\n\n\n\n\n\n","category":"method"},{"location":"msm/","page":"Makorv state models","title":"Makorv state models","text":"msmgenerate(nframe::Int, T, pi_i, emission)","category":"page"},{"location":"msm/#MDToolbox.msmgenerate-Tuple{Int64,Any,Any,Any}","page":"Makorv state models","title":"MDToolbox.msmgenerate","text":"msmgenerate(nframe, T, pi_i, emission) -> states, observations\n\nRandomly samples a state trajectory and observations from the given transition matrix, equilibrium probabilities of states, and emissions.\n\nExamples\n\njulia> T, pi_i = msmtransitionmatrix(C)\njulia> states, observations = msmgenerate(1000, T, pi_i, emission)\n\n\n\n\n\n","category":"method"},{"location":"msm/","page":"Makorv state models","title":"Makorv state models","text":"msmcountmatrix(indexOfCluster; tau=1)","category":"page"},{"location":"msm/#MDToolbox.msmcountmatrix-Tuple{Any}","page":"Makorv state models","title":"MDToolbox.msmcountmatrix","text":"msmcountmatrix(indexOfCluster; tau=1) -> C::Matrix\n\nTransition count matrix from a sinlgle binned trajectory or a set of binned trajectories.  indexOfCluster is a vector or a set of vectors containing binned trajectorie(s).  Returns count matrix for transitions from state i to state j in a time step of tau. \n\nExamples\n\njulia> ta = mdload(\"ak.dcd\")\njulia> X = compute_distancemap(ta[\"atomname CA\"])\njulia> F = clusterkcenters(X)\njulia> c = msmcountmatrix(F.indexOfCluster, tau=10)\n\n\n\n\n\n","category":"method"},{"location":"msm/","page":"Makorv state models","title":"Makorv state models","text":"msmtransitionmatrix(C; TOLERANCE=10^(-4), verbose=true)","category":"page"},{"location":"msm/#MDToolbox.msmtransitionmatrix-Tuple{Any}","page":"Makorv state models","title":"MDToolbox.msmtransitionmatrix","text":"msmtransitionmatrix(C; TOLERANCE=10^(-4), verbose=true) -> T::Matrix, p::Vector\n\nEstimate the transition probability matrix from count matrix C.  Detailed balance is implicitly imposed in the estimation. \n\nReturns the transition probability matrix and the equilibrium probabilities of states. \n\nExamples\n\njulia> ta = mdload(\"ak.dcd\")\njulia> X = compute_distancemap(ta[\"atomname CA\"])\njulia> F = clusterkcenters(X)\njulia> C = msmcountmatrix(F.indexOfCluster, tau=10)\njulia> T, p = msmtransitionmatrix(C)\n\nReferences\n\nThis routines uses the reversible maximum likelihood estimator described in \nK. A. Beauchamp, G. R. Bowman, T. J. Lane, L. Maibaum, I. S. Haque, and V. S. Pande, \nMSMBuilder2: Modeling Conformational Dynamics on the Picosecond to Millisecond Scale, \nJ. Chem. Theory Comput. 7, 3412 (2011).\n\n\n\n\n\n","category":"method"},{"location":"msm/","page":"Makorv state models","title":"Makorv state models","text":"msmviterbi(observation, T, pi_i, emission)","category":"page"},{"location":"msm/#MDToolbox.msmviterbi-NTuple{4,Any}","page":"Makorv state models","title":"MDToolbox.msmviterbi","text":"msmviterbi(observation, T, p, emission) -> states::Vector\n\nViterbi algorithm estimates the most probable hidden state sequence from the observation data. observations is a set of observed vectors. T, p are the transition probabilities and equilibrium probabilities, respectively.  emission is a matrix whose rows correspond to states, and columns correspond to observations. \n\nReturns the transition probability matrix, the equilibrium probabilities of states,  and the emission probabilities (though the emission does not change). \n\nExamples\n\njulia> nframe = 1000\njulia> states, observations = msmgenerate(nframe, T, pi_i, emission)\njulia> states_estimated = msmviterbi(T, pi_i, emission, observation)\n\nReferences\n\nThe algorithm of this routines is based on the descriptions in PRML book by C. Bishop. \n\n\n\n\n\n","category":"method"},{"location":"msm/","page":"Makorv state models","title":"Makorv state models","text":"msmbaumwelch(data_list, T0, pi_i0, emission0; TOLERANCE=10.0^(-4), MAXITERATION=Inf64)","category":"page"},{"location":"msm/#MDToolbox.msmbaumwelch-NTuple{4,Any}","page":"Makorv state models","title":"MDToolbox.msmbaumwelch","text":"msmbaumwelch(observations, T_init, p_init, emission_init; TOLERANCE=10.0^(-4), MAXITERATION=Inf64) -> T::Matrix, p::Vector, emission::Matrix\n\nBaum-Welch algorithm estimates the most probable transition probabilities from the given observation data.  In this function, detailed balance is implicitly imposed in the estimation,  so the equilibrium probabilities can be determined from the estimated transition probabilities.  Also, unlike the original Baum-Welch algorithm, the emission is NOT estimated in this function,  because the emission probabilites are usually known a priori in cases of molecular experiments.  observations is a set of observed vectors. T_init, p_init are initial transition probabilities and equilibrium probabilities, respectively.  emission_init is a matrix whose rows correspond to states, and columns correspond to observations. \n\nReturns the transition probability matrix, the equilibrium probabilities of states,  and the emission probabilities (though the emission does not change). \n\nExamples\n\njulia> ta = mdload(\"ak.dcd\")\njulia> X = compute_distancemap(ta[\"atomname CA\"])\njulia> F = clusterkcenters(X)\njulia> C = msmcountmatrix(F.indexOfCluster, tau=10)\njulia> T, p = msmtransitionmatrix(C)\n\nReferences\n\nThe algorithm of this routines is based on the descriptions in PRML book by C. Bishop. \n\n\n\n\n\n","category":"method"},{"location":"msm/","page":"Makorv state models","title":"Makorv state models","text":"msmplot(T; pi_i=nothing, x=nothing, y=nothing, filename=nothing, edgewidth_scale=3.0, arrow_scale=0.0001, nodesize=0.5, fontsize=10, names=[], dpi=100)","category":"page"},{"location":"msm/#MDToolbox.msmplot-Tuple{Any}","page":"Makorv state models","title":"MDToolbox.msmplot","text":"msmplot(T; pi_i=nothing, x=nothing, y=nothing, filename=nothing, \n        edgewidth_scale=10.0, arrow_scale=0.1, nodesize=0.5, fontsize=10, names=[], dpi=100)\n\nVisualize the graphical structure of the given Markov state model parameters.  T is a transition probability matrix whose elements Tij represents the probablity of transition from state i to j.  T should satisfy the detailed balance condition. pi_i is a vector whose elements are equilibrium probabilities of states.  x and y are X and Y coordinates of states, respectively. \n\nExamples\n\njulia> nstate = 5\njulia> T, pi_i = msmtransitionmatrix(rand(nstate, nstate))\njulia> x = rand(nstate); y = rand(nstate)\njulia> msmplot(T, pi_i=pi_i, x=x, y=y)\n\n\n\n\n\n","category":"method"},{"location":"getting_started01/#Input-and-Output","page":"Input and Output","title":"Input and Output","text":"","category":"section"},{"location":"getting_started01/","page":"Input and Output","title":"Input and Output","text":"Typical usages of I/O functions for MD files are as follows. ","category":"page"},{"location":"getting_started01/#PDB-files","page":"Input and Output","title":"PDB files","text":"","category":"section"},{"location":"getting_started01/","page":"Input and Output","title":"Input and Output","text":"# read pdb data and generate a new variable t whose type is TrjArray\nt = mdload(\"protein.pdb\")\n\n# after some editings\nmdsave(\"protein_edited.pdb\", t)","category":"page"},{"location":"getting_started01/#AMBER-files","page":"Input and Output","title":"AMBER files","text":"","category":"section"},{"location":"getting_started01/","page":"Input and Output","title":"Input and Output","text":"AMBER NetCDF trajectory file","category":"page"},{"location":"getting_started01/","page":"Input and Output","title":"Input and Output","text":"# pdb files can be used for obtaining topology information which is used in atom selections\nt = mdload(\"run.pdb\")\n\n# read AMBER NetCDF data and generate a new variable t whose type is TrjArray\n# the topology information can be attached as the option `top=t`\nt = mdload(\"run.nc\", t=top)\n\n# after some calculations\nmdsave(\"run_edited.nc\", t)","category":"page"},{"location":"getting_started01/#CHARMM/NAMD-files","page":"Input and Output","title":"CHARMM/NAMD files","text":"","category":"section"},{"location":"getting_started01/","page":"Input and Output","title":"Input and Output","text":"# read PSf data and generate a new variable t whose type is TrjArray\n# Although PSF file does not contain coordinates, topology information is used in atom selections\nt = mdload(\"run.psf\")\n# or if you don't have PSF files, pdb can be used to obtain topology information\nt = mdload(\"run.pdb\")\n\n# read dcd file and generate a new variable t whose type is TrjArray\n# the topology information can be attached as the option `top=t`\nt = mdload(\"run.dcd\", top=t)\n# after some calculations\nmdsave(\"run_edit.dcd\", t)","category":"page"},{"location":"getting_started01/#GROMACS-files","page":"Input and Output","title":"GROMACS files","text":"","category":"section"},{"location":"getting_started01/","page":"Input and Output","title":"Input and Output","text":"not available yet","category":"page"},{"location":"reduction/#Reductions","page":"Reductions","title":"Reductions","text":"","category":"section"},{"location":"reduction/","page":"Reductions","title":"Reductions","text":"clusterkcenters(t::AbstractMatrix, kcluster::Int; nReplicates::Int=10)","category":"page"},{"location":"reduction/#MDToolbox.clusterkcenters-Tuple{AbstractArray{T,2} where T,Int64}","page":"Reductions","title":"MDToolbox.clusterkcenters","text":"clusterkcenters(X::AbstractMatrix, kcluster::Int; nReplicates::Int=10) -> F\n\nPerform clustering with K-center algorithm. Input data X should belong to AbstractMatrix type  and its columns corresponds to variables, rows are frames. Also, the number of clusters kcluster should be specified. \n\nReturns a NamedTuple object F which contains cluster index for each sample in F.indexOfCluster, the coordinates of cluster centers in F.center, the indices of cluster centers in F.indexOfCenter,  and distances of samples from the nearest centers in F.distanceFromCenter.\n\nExample\n\njulia> using MDToolbox, Plots\njulia> X = rand(1000, 2)\njulia> F = clusterkcenters(X, 3)\njulia> scatter(X[:, 1], X[:, 2], c=F.indexOfCluster)\n\nReferences\n\nThis function uses the method described in\n[1] S. Dasgupta and P. M. Long, J. Comput. Syst. Sci. 70, 555 (2005).\n[2] J. Sun, Y. Yao, X. Huang, V. Pande, G. Carlsson, and L. J. Guibas, Learning 24, 2 (2009).\n\n\n\n\n\n","category":"method"},{"location":"reduction/","page":"Reductions","title":"Reductions","text":"clusterkcenters(ta::TrjArray, kcluster::Int; nReplicates::Int=10)","category":"page"},{"location":"reduction/#MDToolbox.clusterkcenters-Tuple{TrjArray,Int64}","page":"Reductions","title":"MDToolbox.clusterkcenters","text":"clusterkcenters(ta::AbstractMatrix, kcluster::Int; nReplicates::Int=10) -> F\n\nPerform clustering with K-center algorithm for a TrjArray variable ta.\n\n\n\n\n\n","category":"method"},{"location":"reduction/","page":"Reductions","title":"Reductions","text":"compute_cov(X::AbstractMatrix; lagtime::Int=0)","category":"page"},{"location":"reduction/#MDToolbox.compute_cov-Tuple{AbstractArray{T,2} where T}","page":"Reductions","title":"MDToolbox.compute_cov","text":"compute_cov(ta::AbstractMatrix, lagtime::Int=0) -> cov\n\nCompute a variance-covariance or time-lagged covariance matrix from input data X Input data X should belong to AbstractMatrix type and its columns corresponds to variables, rows are frames. Optional input is the lagtime=lagtime for the calculation of the covariance matrix (default is lagtime=0). \n\nExample\n\njulia> X = rand(1000, 100)\njulia> cov = compute_cov(X)\n\n\n\n\n\n","category":"method"},{"location":"reduction/","page":"Reductions","title":"Reductions","text":"rsvd(A::AbstractMatrix, k::Number=10)","category":"page"},{"location":"reduction/#MDToolbox.rsvd","page":"Reductions","title":"MDToolbox.rsvd","text":"rsvd(X::AbstractMatrix; k::Number=10) -> F\n\nPerform the randomized SVD for input data X. Input data X should belong to AbstractMatrix type and its columns corresponds to variables, rows are frames.  Users can specify the dimension k of subspace onto which the data is randomly projected (by default k=10). \n\nReturns a NamedTuple object F whose members are same as usual SVD, F.V, F.S, F.U. \n\nExample\n\njulia> X = randn(rand(1000, 10))\njulia> F = rsvd(X)\n\nReferences\n\nHalko, Nathan, Per-Gunnar Martinsson, and Joel A. Tropp. \n\"Finding structure with randomness: Probabilistic algorithms for constructing approximate matrix decompositions.\" \nSIAM review 53.2 (2011): 217-288.\n\n\n\n\n\n","category":"function"},{"location":"reduction/","page":"Reductions","title":"Reductions","text":"pca(X::AbstractMatrix; k=nothing)","category":"page"},{"location":"reduction/#MDToolbox.pca-Tuple{AbstractArray{T,2} where T}","page":"Reductions","title":"MDToolbox.pca","text":"pca(X::AbstractMatrix; k=dimension) -> F\n\nPerform principal component analysis (PCA). PCA captures degrees of freedom which have the largest variances. Input data X should belong to AbstractMatrix type and its columns corresponds to variables, rows are frames. \n\nReturns a NamedTuple object F which contains the principal components in F.projection,  the prncipal modes in the columns of the matrix F.mode, and the variances of principal components in F.variance. \n\nIf k=dimension is specified, the randomized SVD is used for reducing memory.  This algorithm first project the data into a randomly selected k+2-dimensional space,  then PCA is performed in the projected data. See the references for details.  Note that if the dimension of X is larger than 5000, the randomized SVD is forcibly used with k=1000. \n\nExample\n\njulia> using MDToolbox, Plots, Statistics\njulia> X = cumsum(rand(1000, 10))\njulia> F = pca(X)\njulia> plot(F.projection[:, 1], F.projection[:, 2])\n\nReferences\n\nHalko, N., Martinsson, P.-G., Shkolnisky, Y. & Tygert, M. \nAn Algorithm for the Principal Component Analysis of Large Data Sets. \nSIAM J. Sci. Comput. 33, 2580–2594 (2011).\n\n\n\n\n\n","category":"method"},{"location":"reduction/","page":"Reductions","title":"Reductions","text":"tica(X::AbstractMatrix, lagtime::Int=1)","category":"page"},{"location":"reduction/#MDToolbox.tica","page":"Reductions","title":"MDToolbox.tica","text":"tica(X::AbstractMatrix, lagtime::Int=1) -> F\n\nThis routine performs time-structure based Independent Component Analysis (tICA). tICA captures degrees of freedom which are most important in the sense that their motions are very slow. X belongs to AbstractMatrix type and its columns corresponds to variables, rows are frames.  User should specify the lagtime for the calculation of the time-lagged covariance matrix.  Returns a NamedTuple object F which contains independent components in F.projection,  the independent modes in the columns of the matrix F.mode, and the eigenvalues in F.variance. \n\nIf the dimension of X is larger than 5000, the randomized SVD approximation is forcibly used with k=1000 to reduce memory. \n\nExample\n\njulia> using MDToolbox, Plots, Statistics\njulia> X = cumsum(rand(1000, 10))\njulia> F = tica(X, 10)\njulia> plot(F.projection[:, 1], F.projection[:, 2])\n\nReferences\n\nNaritomi, Y. & Fuchigami, S. \nSlow dynamics in protein fluctuations revealed by time-structure based independent component analysis: \nThe case of domain motions. \nThe Journal of Chemical Physics 134, 065101 (2011).\n\n\n\n\n\n","category":"function"},{"location":"getting_started02/#TrjArray-type","page":"TrjArray type","title":"TrjArray type","text":"","category":"section"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"MDToolbox.jl uses a unique type, called TrjArray, for storing and processing MD data.  When you load MD data with mdload(), mdload() always generates a variable of TrjArray type. Alternatively, a TrjArray-type variable can be manually generated by calling its constructor:","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"# A TrjArray variable generated by loading MD data\nt = mdload(\"run.dcd\")\n\n# Generate a TrjArray by calling its constructor. Here, single atom and its nine-frame coordinates are given. \nt = TrjArray(xyz=rand(10, 3))","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"TrjArray displays the information of its topology and trajectory on the standard ouput for users. For example, the following are the outputs from TrjArray just after loading a pdb file. ","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"t = mdload(\"1nmr.pdb\")\n20x1290 TrjArray{Float64, Int64}\n| A                          | A                          | A                          |  …   A                          | A                          |\n| 1GLY                       | 1GLY                       | 1GLY                       |  …   85VAL                      | 85VAL                      |\n| 1N                         | 2CA                        | 3C                         |  …   1289HG22                   | 1290HG23                   |\n|    28.53   -26.27   -28.94 |    29.17   -26.75   -27.68 |    29.57   -25.61   -26.77 |  …      -7.86   -13.77     5.44 |    -9.59   -13.85     5.12 |\n|    14.90   -22.61   -39.37 |    15.46   -21.51   -38.53 |    14.63   -21.25   -37.29 |        -12.22   -15.81    16.41 |   -13.19   -16.57    17.66 |\n|    23.41    -2.86   -46.88 |    22.10    -3.25   -47.48 |    21.09    -3.72   -46.45 |        -20.27   -10.55    13.26 |   -18.87   -11.64    13.29 |\n|    32.55     2.61   -26.67 |    33.27     3.91   -26.53 |    34.03     4.01   -25.23 |        -17.33   -15.69    15.29 |   -18.58   -15.84    16.52 |\n|    28.06    -2.79     6.71 |    26.82    -2.08     7.14 |    25.79    -1.99     6.03 |        -15.29    -8.49     7.07 |   -13.81    -7.58     7.35 |\n|    18.58     1.82   -32.61 |    18.49     2.73   -33.78 |    17.08     3.23   -34.03 |  …     -11.52   -13.25    13.40 |   -10.73   -11.69    13.65 |\n|    18.83   -25.48   -17.28 |    19.60   -24.35   -17.87 |    20.66   -24.82   -18.85 |         -9.46   -13.49    12.92 |   -10.70   -12.47    13.67 |\n|    23.19   -14.27   -19.63 |    24.34   -14.74   -18.81 |    24.34   -14.16   -17.41 |        -15.02   -11.41     7.39 |   -16.62   -11.77     8.03 |\n|    13.03     4.56   -33.69 |    13.94     4.98   -34.80 |    14.57     6.34   -34.54 |         -8.15   -13.56    16.57 |    -7.91   -12.72    18.11 |\n|    33.84   -12.66   -35.98 |    33.07   -12.78   -34.72 |    33.80   -12.20   -33.53 |        -26.30    -5.86    15.89 |   -27.17    -5.87    14.35 |\n|    16.87    -4.29   -29.61 |    17.68    -4.56   -30.84 |    18.55    -3.38   -31.22 |  …     -12.64    -9.46    13.16 |   -12.40   -10.92    14.13 |\n|    -0.75    -1.61   -29.23 |     0.53    -1.27   -28.55 |     1.75    -1.63   -29.38 |        -13.61   -13.56    20.23 |   -12.35   -14.79    20.13 |\n|    18.30    -7.25   -33.42 |    19.19    -8.43   -33.59 |    19.44    -9.15   -32.28 |        -16.17   -16.37    14.80 |   -16.02   -14.71    15.36 |\n|     5.11   -12.01   -17.20 |     6.47   -11.52   -17.57 |     6.77   -11.71   -19.04 |         -4.85    -9.56     8.53 |    -3.89    -9.68    10.00 |\n|    25.43     1.83   -30.51 |    26.00     1.39   -31.81 |    26.16     2.54   -32.79 |        -23.89    -7.36    17.90 |   -22.18    -7.18    18.30 |\n|    12.85   -11.80   -35.78 |    11.42   -11.45   -35.56 |    11.08   -11.26   -34.10 |  …     -24.66     0.20    14.78 |   -23.75    -1.22    15.28 |\n|    16.98     0.72   -33.26 |    16.95     0.68   -34.75 |    16.06    -0.43   -35.28 |        -13.51   -12.24    21.06 |   -13.74   -13.90    20.52 |\n|    15.89    -2.89   -34.57 |    14.46    -2.58   -34.81 |    13.54    -3.75   -34.51 |        -14.64    -5.21     8.71 |   -15.94    -5.95     9.64 |\n|    30.24    11.26   -16.06 |    30.76    12.62   -15.76 |    30.91    13.47   -17.00 |         -6.57   -15.12    20.61 |    -7.38   -15.35    19.06 |\n|    28.91    17.14   -29.35 |    27.45    17.34   -29.54 |    26.67    17.19   -28.25 |        -21.13   -14.49    14.75 |   -21.74   -14.16    13.12 |","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"Here, the first three rows display the topology infomation contained in the TrjArray-type variable t. The 1st row shows chain IDs and names. The 2nd row shows residue IDs and names. The 3rd row shows atom IDs and names. ","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"The rest of the rows are the XYZ coordinates of each atoms. Different rows corresponds to different frames. So, the coordinates of an each structure are displayed in an each single row. ","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"The users can directly access to the topology and trajectory data contained in a TrjArray-type variable. For example, atomnames can be accessed by t.atomname","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"t.atomname\n","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"Trajectory variable is a matrix whose row vectors consist of coordinate variables. The rows represent frames in the trajectory.  For simulation data, the sequence of frames represents molecular dynamics. ","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"Thus, for example, the coordinate at the 10th frame is extracted by ::","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"crd = trj(10, :);","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"Translation in the x-axis throughout all frames is coded as ::","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"trj(:, 1:3:end) = trj(:, 1:3:end) + 3.0;","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"Average coordinate over all frames (without fitting) is obtained by ::","category":"page"},{"location":"getting_started02/","page":"TrjArray type","title":"TrjArray type","text":"crd = mean(trj);","category":"page"},{"location":"fileio/#File-IO","page":"File IO","title":"File IO","text":"","category":"section"},{"location":"fileio/","page":"File IO","title":"File IO","text":"mdload(filename::AbstractString; index=nothing, top=nothing)","category":"page"},{"location":"fileio/#MDToolbox.mdload-Tuple{AbstractString}","page":"File IO","title":"MDToolbox.mdload","text":"mdload(filename::AbstractString; index=nothing, top::TrjArray=nothing) -> ta::TrjArray\n\nFunction for reading bimolecular structure files or molecular dynamics trajectories.  This function automatically detects files types from the filename extension of input filename.  Currently, PDB, PSF, DCD, and NetCDF formats are available.  For reading subset atoms from the trajectory files, the user can specify atom indices as index::AbstractVector{Int}. Returns a TrjArray variable ta. \n\nIf the user wants to attach a topology information read from PSF, PDB, or other files to MD trajectory,  the user can give an addtional option top=ta:TrjArray. If the option is given the topology information is applied. \n\nExample\n\njulia> ta = mdload(\"1ake.psf\")\njulia> ta = mdload(\"1ake.dcd\", top=ta)\n\n\n\n\n\n","category":"method"},{"location":"fileio/","page":"File IO","title":"File IO","text":"mdsave(filename::AbstractString, ta::TrjArray)","category":"page"},{"location":"fileio/#MDToolbox.mdsave-Tuple{AbstractString,TrjArray}","page":"File IO","title":"MDToolbox.mdsave","text":"mdsave(filename::AbstractString, ta::TrjArray)\n\nFunction for writing bimolecular structure files or molecular dynamics trajectories.  This function automatically detects files types from the filename extension of input filename.  Currently, PDB, PSF, and NetCDF formats are available. \n\nExample\n\njulia> ta = TrjArray(xyz=randn(100, 9))\njulia> ta = mdsave(\"1ake.nc\", ta)\n\n\n\n\n\n","category":"method"},{"location":"license/","page":"License","title":"License","text":"MDToolbox.jl is licensed under the BSD 3-Clause License.","category":"page"},{"location":"license/","page":"License","title":"License","text":"Author: Yasuhiro Matsunaga (ymatsunaga@mail.saitama-u.ac.jp), Tomonori Ogane  Copyright (c) 2018-2019, RIKEN.  Copyright (c) 2019-2021, Saitama University  All rights reserved.Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions are  met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution\nNeither the name of RIKEN nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"license/","page":"License","title":"License","text":"It should be mentioned this package contains the following codes for convenience. Please note that these are not covered by the license under which a copy of MDToolbox.jl is licensed to you, while neither composition nor distribution of any derivative work of MDToolbox.jl with these software violates the terms of each license, provided that it meets every condition of the respective licenses.","category":"page"},{"location":"license/","page":"License","title":"License","text":"– superimpose() in structure.jl is a porting of original C code to Julia and licensed under the BSD license.","category":"page"},{"location":"license/","page":"License","title":"License","text":"The website for this software is located at:  http://theobald.brandeis.edu/qcp/    Copyright (c) 2009-2012 Pu Liu and Douglas L. Theobald  All rights reserved.Redistribution and use in source and binary forms, with or without  modification, are permitted provided that the following conditions are  met:Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of the <ORGANIZATION> nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","category":"page"},{"location":"license/","page":"License","title":"License","text":"afmize() in afm.jl is a porting of original C++ code to Julia and licensed under the MIT license","category":"page"},{"location":"license/","page":"License","title":"License","text":"The website for this software is located at:  https://github.com/ToruNiina/afmize/blob/master/LICENSECopyright (c) 2018 Toru Niina  All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"getting_started03/#Atom-selection","page":"Atom selection","title":"Atom selection","text":"","category":"section"},{"location":"structure/#Structural-computations","page":"Structural computations","title":"Structural computations","text":"","category":"section"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"centerofmass(ta::TrjArray{T, U}; isweight::Bool=true, index::AbstractVector=Vector{U}(undef, 0)) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.centerofmass-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}} where U where T","page":"Structural computations","title":"MDToolbox.centerofmass","text":"centerofmass(ta::TrjArray; isweight=true, index::Union{UnitRange,Vector,BitArray}) -> com::TrjArray\n\nCalculates the center of mass coordinates (COM) of the given trajectory, a TrjArray object ta.  If isweight is true (default), coordinates are weighted by ta.mass (as long as ta.mass is not empty). Uses can also specify column indices for the COM calculation by giving index which should be a Vector of integers, a UnitRange, or a BiArray. \n\nReturns the center of mass coordinates as a TrjArray object, which have virtual single \"atom\" whose coordinates are COMs. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> com = centersofmass(ta)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"decenter(ta::TrjArray{T, U}; isweight::Bool=true, index::AbstractVector=Vector{Int64}(undef, 0)) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.decenter-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}} where U where T","page":"Structural computations","title":"MDToolbox.decenter","text":"decenter(ta::TrjArray; isweight=true, index::Union{UnitRange,Vector,BitArray}) -> ta_decentered::TrjArray, com::TrjArray\n\nCalculates the centers of mass coordinates (COM) of the given trajectory, a TrjArray object ta. And translates the coordinates so that the COM of the output is identical to the origin (x=y=z=0).  If isweight is true (default), coordinates are weighted by ta.mass (as long as ta.mass is not empty). Uses can also specify column indices for the COM calculation by giving index which should be a Vector of integers, a UnitRange, or a BiArray. \n\nReturns a TrjArray object whose COM is the origin (x=y=z=0), and the COM of the given TrjArray ta. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> ta_decentered = decenter(ta)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"decenter!(ta::TrjArray{T, U}; isweight::Bool=true, index::AbstractVector=Vector{Int64}(undef, 0)) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.decenter!-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}} where U where T","page":"Structural computations","title":"MDToolbox.decenter!","text":"decenter!(ta::TrjArray; isweight=true, index=[])\n\nTranslates the coordinates of the given trajectory, a TrjArray ta,  so that the COM of it become identical to the origin (x=y=z=0).  If isweight is true (default), coordinates are weighted by ta.mass (as long as ta.mass is not empty). Uses can also specify column indices for the COM calculation by giving index which should be an Array of integers. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> decenter!(ta)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"rotate(ta::TrjArray{T, U}, quater::AbstractVector{T}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.rotate-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},AbstractArray{T,1}}} where U where T","page":"Structural computations","title":"MDToolbox.rotate","text":"rotate(ta::TrjArray, quaternion::Vector) -> ta_rotated::TrjArray\n\nPerforms rotation of coordinates of the given TrjArray object ta.  Rotation matrix is constructed fromt the given quaternion vector. \n\nReturns the trajecotry with rotated coordinates.\n\nExample\n\njulia> ta = mdload(\"ak.dcd\")\njulia> quaternion = [0.80951112,  0.10657412,  0.35146912,  0.45804312]\njulia> ta_rotated = rotate(ta, quaternion)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"rotate!(ta::TrjArray{T, U}, quater::AbstractVector{T}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.rotate!-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},AbstractArray{T,1}}} where U where T","page":"Structural computations","title":"MDToolbox.rotate!","text":"rotate!(ta::TrjArray, quaternion::Vector)\n\nPerforms rotation of coordinates of the given TrjArray object ta.  Rotation matrix is constructed fromt the given quaternion vector. \n\nThe coordinates of ta is replaced with the rotated ones. \n\nExample\n\njulia> ta = mdload(\"ak.dcd\")\njulia> quaternion = [0.80951112,  0.10657412,  0.35146912,  0.45804312]\njulia> rotate!(ta, quaternion)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"rotate(ta_single::TrjArray{T, U}, quater::AbstractMatrix{T}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.rotate-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},AbstractArray{T,2}}} where U where T","page":"Structural computations","title":"MDToolbox.rotate","text":"rotate(ta::TrjArray, quaternions::Matrix) -> ta_rotated::TrjArray\n\nPerforms multiple rotations of the coordinates of the 1st frame of the given TrjArray object ta.  Rotation matrices are construcuted from the 2-dimensional Array quaternions. One set of quaternions for rotaton should be given in a row vector in quaternions. \n\nReturns the trajecotry with rotated coordinates from the 1st frame of ta. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> quaternions = [0.80951112  0.10657412  0.35146912  0.45804312; \n>                     0.10657412  0.80951112  -0.35146912  0.45804312]\njulia> ta_rotated = rotate(ta, quaternions)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"rotate_with_matrix(ta::TrjArray{T, U}, R::AbstractMatrix{T}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.rotate_with_matrix-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},AbstractArray{T,2}}} where U where T","page":"Structural computations","title":"MDToolbox.rotate_with_matrix","text":"rotate_with_matrix(ta::TrjArray, R::Matrix) -> ta_rotated::TrjArray\n\nPerforms rotation of coordinates of the given TrjArray object ta with the given rotation matrix. \n\nThe coordinates of ta is replaced with the rotated ones. \n\nExample\n\njulia> ta = mdload(\"ak.dcd\")\njulia> R = [0.36 0.48 -0.8;\n            -0.8 0.60 0.0;\n            -.48 0.64 0.60]\njulia> ra_rotated = rotate(ta, R)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"superimpose(ref::TrjArray{T, U}, ta::TrjArray{T, U}; isweight::Bool=true, index::AbstractVector=Vector{U}(undef, 0), isdecenter::Bool=false) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.superimpose-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},TrjArray{T,U}}} where U where T","page":"Structural computations","title":"MDToolbox.superimpose","text":"superimpose(ref::TrjArray, ta::TrjArray; isweight=true, index::Union{UnitRange,Vector,BitArray}, isdecenter=false) -> ta_superimposed::TrjArray\n\nPerforms the least-squares fitting of the given trajectory (TrjArray object ta)  to the reference structure (1st frame of TrjArray object ref).  If isweight is true (default), coordinates are weighted by ta.mass (as long as ta.mass is not empty). Uses can specify column indices for the COM calculation by giving index which should be a Vector of integers, a UnitRange, or a BiArray.  When isdecenter is true, the function assumes the COMs of both structures are located at the origin (default is isdecenter=false). \n\nReturns the superimposed trajecotry. \n\nThe code of this function is licensed under the BSD license (Copyright (c) 2009-2016 Pu Liu and Douglas L. Theobald), see LICENSE.md\n\nExample\n\njulia> ref = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=pdb)\njulia> ta_superimposed = superimpose(ref, ta)\n\nReferences\n\nThe algorithm of this function is based on \nP. Liu, D. K. Agrafiotis, and D. L. Theobald, \nJ. Comput. Chem. 31, 1561-1563 (2010).\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_rmsd(ref::TrjArray{T, U}, ta::TrjArray{T, U}; isweight::Bool=true, index::AbstractVector=Vector{U}(undef, 0)) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_rmsd-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},TrjArray{T,U}}} where U where T","page":"Structural computations","title":"MDToolbox.compute_rmsd","text":"compute_rmsd(ref::TrjArray, ta::TrjArray; isweight=true, index=index::Union{UnitRange,Vector,BitArray}) -> rmsd\n\nCalculates the root mean square deviations (RMSD) of the given trajectory (TrjArray object ta) from the reference structure (1st frame of TrjArray object ref).  If isweight is true (default), coordinates are weighted by ta.mass (as long as ta.mass is not empty). Uses can specify column indices for the RMSD calculation by giving index which should be a Vector of integers, a UnitRange, or a BiArray. \n\nReturns RMSD values. \n\nExample\n\njulia> ref = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.nc\", top=pdb)\njulia> ta_superimposed = superimpose(ref, ta)\njulia> rmsd = compute_rmsd(ref, ta_superimposed)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"meanstructure(ta::TrjArray{T, U}; isweight::Bool=true, index::Vector{U}=Vector{U}(undef, 0)) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.meanstructure-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}} where U where T","page":"Structural computations","title":"MDToolbox.meanstructure","text":"meanstructure(ta::TrjArray; isweight=true, index=index::Union{UnitRange,Vector,BitArray}) -> ta_mean::TrjArray, ta_superimposed::TrjArray\n\nCalculates the mean structure of the given trajectory (TrjArray object ta) by iteratively fitting the trajecotry to tentative mean structures until the mean structure converges.  If isweight is true (default), coordinates are weighted by ta.mass (as long as ta.mass is not empty). Uses can specify column indices for the fitting (superimpose function) by giving index which should be a Vector of integers, a UnitRange, or a BiArray. \n\nReturns the mean structure as TrjArray object, and the supserimposed trajectory to the mean structure. \n\nExample\n\njulia> ta = mdload(\"ak.nc\", top=pdb)\njulia> ta_mean, ta_superimposed = meanstructure(ta)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_rmsf(ta::TrjArray{T, U}; isweight::Bool=true) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_rmsf-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}} where U where T","page":"Structural computations","title":"MDToolbox.compute_rmsf","text":"compute_rmsf(ta::TrjArray{T, U}; isweight::Bool=true) -> rmsf\n\nrmsf (root mean square fluctuation)\n\nCalculates the root mean square fluctuations (RMSFs) of the atoms in the given trajectory (TrjArray object ta).  from the average coordinates of the trajectory.  If isweight is true (default), coordinates are weighted by ta.mass (as long as ta.mass is not empty).\n\nReturns RMSF values. \n\nExample\n\njulia> ta = mdload(\"ak.nc\", top=pdb)\njulia> ta_mean, ta_superimposed = meanstructure(ta)\njulia> rmsf = compute_rmsf(ta)\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_distance(ta::TrjArray{T, U}, index=[1 2]::Matrix{U}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_distance-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},Any}} where U where T","page":"Structural computations","title":"MDToolbox.compute_distance","text":"compute_distance(ta::TrjArray, index::Matrix)\n\nCalculates distances between two atom pairs specified by the Matrix object index.  Each row vector in index contains two column indices for calculating distance.  Default of index is [1 2]. \n\nReturns distances specified pairs in index. \n\nExample\n\njulia> ta = mdload(\"ak.dcd\")\njulia> d = compute_distance(ta, [1 2; 1; 3])\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_distance(ta1::TrjArray{T, U}, ta2::TrjArray{T, U}, index=[1 1]::Matrix{U}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_distance-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},TrjArray{T,U}}, Tuple{TrjArray{T,U},TrjArray{T,U},Any}} where U where T","page":"Structural computations","title":"MDToolbox.compute_distance","text":"compute_distance(ta1::TrjArray, ta2::TrjArray, index::Matrix)\n\nCalculates distances between two atom pairs in ta1 and ta2 specified by the Matrix object index.  Each row vector in index contains a column index of ta1 and column index of ta2 for calculating distance.  Default of index is [1 1]. \n\nReturns distances specified pairs in index. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=ta)\njulia> d = compute_distance(ta[:, \"atomid 1\"], ta[:, \"atomid 9\"])\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_distancemap(ta::TrjArray{T, U}; kneighbor=3) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_distancemap-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}} where U where T","page":"Structural computations","title":"MDToolbox.compute_distancemap","text":"compute_distancemap(ta::TrjArray; kneighbor=3)\n\nCalculates distance-map vectors from the given TrjArray ta.  If atomid=j and atomid=i are closer to each other than the specified kneighbor, i.e., abs(i-j) < kneighbor,  the calculation of the distance is ignored, considering that they are not nonbonded pairs.  The default value of kneighbor is 3. \n\nReturns distance-map vectors of all frames. The distance-map of each frame is contained in a row vector of the output.\n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=ta)\njulia> d = compute_distancemap(ta[\"atomname CA\"])\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_contactmap(ta::TrjArray{T, U}; rcut=8.5, kneighbor=3) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_contactmap-Union{Tuple{TrjArray{T,U}}, Tuple{U}, Tuple{T}} where U where T","page":"Structural computations","title":"MDToolbox.compute_contactmap","text":"compute_contactmap(ta::TrjArray; rcut=8.5, kneighbor=3)\n\nCalculates contact-map vectors from the given TrjArray ta.  Cut-off value for contact can be given in rcut (default is rcut=8.5).  If atomid=j and atomid=i are closer to each other than the specified kneighbor, i.e., abs(i-j) < kneighbor,  the calculation of the distance is ignored, considering that they are not nonbonded pairs.  The default value of kneighbor is 3. \n\nReturns contact-map vectors of all frames. The contact-map of each frame is contained in a row vector of the output. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=ta)\njulia> d = compute_distancemap(ta[\"atomname CA\"])\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_angle(ta1::TrjArray{T, U}, ta2::TrjArray{T, U}, ta3::TrjArray{T, U}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_angle-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},TrjArray{T,U},TrjArray{T,U}}} where U where T","page":"Structural computations","title":"MDToolbox.compute_angle","text":"compute_angle(ta1::TrjArray, ta2::TrjArray, ta3::TrjArray)\n\nCalculates angles for the atom coordinates or the COMs of groups from the triplet of ta1, ta2 and ta3. \n\nReturns angles.\n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=ta)\njulia> a = compute_distance(ta[:, \"atomid 1\"], ta[:, \"atomid 9\"], ta[:, \"atomid 11\"])\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_dihedral(ta1::TrjArray{T, U}, ta2::TrjArray{T, U}, ta3::TrjArray{T, U}, ta4::TrjArray{T, U}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_dihedral-Union{Tuple{U}, Tuple{T}, NTuple{4,TrjArray{T,U}}} where U where T","page":"Structural computations","title":"MDToolbox.compute_dihedral","text":"compute_dihedral(ta1::TrjArray, ta2::TrjArray, ta3::TrjArray, ta4::TrjArray)\n\nCalculates dihedral angles for the atom coordinates or the COMs of groups from the quadruplet of ta1, ta2, ta3 and ta4. \n\nReturns dihedral angles.\n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=ta)\njulia> d = compute_dihedral(ta[:, \"atomid 1\"], ta[:, \"atomid 9\"], ta[:, \"atomid 11\", ta[:, \"atom 13\"]])\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_dihedral(ta::TrjArray{T, U}, array_index) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_dihedral-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},Any}} where U where T","page":"Structural computations","title":"MDToolbox.compute_dihedral","text":"compute_dihedral(ta1::TrjArray, ta2::TrjArray, ta3::TrjArray, ta4::TrjArray)\n\nCalculates dihedral angles for the atom coordinates or the COMs of groups from the quadruplet of ta1, ta2, ta3 and ta4. \n\nReturns dihedral angles.\n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=ta)\njulia> d = compute_dihedral(ta[:, \"atomid 1\"], ta[:, \"atomid 9\"], ta[:, \"atomid 11\", ta[:, \"atom 13\"]])\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_qscore(native::TrjArray{T, U}, ta::TrjArray{T, U}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_qscore-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},TrjArray{T,U}}} where U where T","page":"Structural computations","title":"MDToolbox.compute_qscore","text":"compute_qscore(native::TrjArray, ta::TrjArray) -> qscore::Array\n\nCalculates all-atom based Q-score from given heavy atom coordinates. \n\nReturns Q-scores. \n\nExample\n\njulia> native = mdload(\"ak.pdb\")\njulia> ta = mdload(\"ak.dcd\", top=native)\njulia> qscore = compute_qscore(native[\"not hydrogen\"], ta[\"not hydrogen\"])\n\nReferences\n\nDefinition of Q-score from heavy atoms is given in \nR. B. Best, G. Hummer, and W. A. Eaton, PNAS 110, 17874 (2013).\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_drms(native1::TrjArray{T, U}, native2::TrjArray{T, U}, ta1::TrjArray{T, U}, ta2::TrjArray{T, U}) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_drms-Union{Tuple{U}, Tuple{T}, NTuple{4,TrjArray{T,U}}} where U where T","page":"Structural computations","title":"MDToolbox.compute_drms","text":"compute_drms(native1::TrjArray, native2::TrjArray, ta1::TrjArray, ta2::TrjArray) -> drms\n\nCalculates distance-based root mean square displacements (DRMS) from the given trajectories.  First, native contacts between molecule1 and molecule2 are identified from the two native structures native1 and native2 where cutoff distance of 6.0 Angstrom is used.  Then, the DRMS are calculated from the trajectories of molecule1 ta1 and molecule2 ta2. \n\nReturns distance-based root mean square displacements. \n\nExample\n\njulia> native1 = mdload(\"protein.pdb\")[\"not hydrogen\"]\njulia> native2 = mdload(\"ligand.pdb\")[\"not hydrogen\"]\njulia> ta1 = mdload(\"protein.dcd\")[\"not hydrogen\"]\njulia> ta2 = mdload(\"ligand.dcd\")[\"not hydrogen\"]\njulia> drms = compute_drms(native1, native2, ta1, ta2)\n\nReferences\n\nDefinition of DRMS is given in \nJ. Domański, G. Hedger, R. B. Best, P. J. Stansfeld, and M. S. P. Sansom, \nConvergence and Sampling in Determining Free Energy Landscapes for Membrane Protein Association, \nJ. Phys. Chem. B 121, 3364 (2017).\n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_pairlist(ta::TrjArray{T, U}, rcut::T; iframe=1::Int) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_pairlist-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},T}} where U where T","page":"Structural computations","title":"MDToolbox.compute_pairlist","text":"compute_pairlist(ta::TrjArray, rcut; iframe=1::Int) -> F\n\nMake a pairlist for the given strcuture ta1 by searching pairs within a cutoff distance rcut.  By default, the 1st frame of ta1 is used. Users can specify the frame by iframe. \n\nReturns a NamedTuple object F which contains the pair lists in F.pair,  and the distances of corresponding pairs in F.dist. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> F = compute_pairlist(ta, 8.0)\n\nReferences\n\nThe algorithm of this function is based on \nT.N. Heinz, and P.H. Hünenberger, \nA fast pairlist-construction algorithm for molecular simulations under periodic boundary conditions. \nJ Comput Chem 25, 1474–1486 (2004). \n\n\n\n\n\n","category":"method"},{"location":"structure/","page":"Structural computations","title":"Structural computations","text":"compute_pairlist_bruteforce(ta::TrjArray{T, U}, rcut::T; iframe=1::Int) where {T, U}","category":"page"},{"location":"structure/#MDToolbox.compute_pairlist_bruteforce-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T,U},T}} where U where T","page":"Structural computations","title":"MDToolbox.compute_pairlist_bruteforce","text":"compute_pairlist_bruteforce(ta::TrjArray, rcut; iframe=1::Int) -> F\n\nBruteforce search version of compute_pairlist function. Mainly used for debugging. \n\nReturns a NamedTuple object F which contains the pair lists in F.pair,  and the distances of corresponding pairs in F.dist. \n\nExample\n\njulia> ta = mdload(\"ak.pdb\")\njulia> F = compute_pairlist(ta, 8.0)\n\n\n\n\n\n","category":"method"},{"location":"#MDToolbox.jl","page":"MDToolbox.jl","title":"MDToolbox.jl","text":"","category":"section"},{"location":"","page":"MDToolbox.jl","title":"MDToolbox.jl","text":"MDToolbox.jl is a Julia package for molecular dynamics (MD) trajectories analysis and modeling of biomolecules. The package contains functions covering the following types of scientific computations:","category":"page"},{"location":"","page":"MDToolbox.jl","title":"MDToolbox.jl","text":"I/O for trajectory, coordinate, and topology files used for MD simulations\nUnique type (TrjArray) for MD trajectory data\nFlexible atom selections\nLeast-squares fitting of structures\nPotential of mean force (PMF) or free energy profile from unbiased MD trajectories\nStatistical estimates (WHAM and MBAR methods) from biased MD trajectories\nDimensional reductions (Principal Component Analysis, and others)\nMarkov state model, etc. ","category":"page"},{"location":"","page":"MDToolbox.jl","title":"MDToolbox.jl","text":"Some functions have been ported into this package from our old MATLAB toolbox https://github.com/ymatsunaga/mdtoolbox","category":"page"},{"location":"#Citations","page":"MDToolbox.jl","title":"Citations","text":"","category":"section"},{"location":"","page":"MDToolbox.jl","title":"MDToolbox.jl","text":"In preparation","category":"page"},{"location":"#Contents","page":"MDToolbox.jl","title":"Contents","text":"","category":"section"},{"location":"","page":"MDToolbox.jl","title":"MDToolbox.jl","text":"Pages = [\"installation.md\",\n        \"getting_started01.md\", \n        \"getting_started02.md\", \n        \"getting_started03.md\", \n        \"fileio.md\", \n        \"structure.md\", \n        \"reduction.md\", \n        \"wham.md\", \n        \"mbar.md\", \n        \"msm.md\", \n        \"license.md\"]\nDepth = 2","category":"page"},{"location":"wham/#WHAM-(Weighted-Histogram-Analysis-Method)","page":"WHAM (Weighted Histogram Analysis Method)","title":"WHAM (Weighted Histogram Analysis Method)","text":"","category":"section"},{"location":"wham/","page":"WHAM (Weighted Histogram Analysis Method)","title":"WHAM (Weighted Histogram Analysis Method)","text":"wham(h_km, bias_km; ftol=1e-10, iterations=10^5)","category":"page"},{"location":"wham/#MDToolbox.wham-Tuple{Any,Any}","page":"WHAM (Weighted Histogram Analysis Method)","title":"MDToolbox.wham","text":"wham(h_km, bias_km; ftol=1e-10, maxiterations=10^5) -> F\n\nEstimates (reduced) free energies of umbrella-windows and potential of mean force in data-bins by using the WHAM equations. K is # of umbrellas and M is # of bins. h_km is a K x M Array which is a histogram (data counts) of k-th umbrella data in m-th bin. bias_km is also a K x M Array which is a bias-factor of k-th umbrella-window evaluated at m-th bin-center. \n\nReturns a NamedTuple object F whose members are F.f_k reduced relative free energies of umbrella-windows,  and pmf_m reduced potential of mean force in data-bins under unbiased condition. \n\nReferences\n\nS. Kumar, D. Bouzida, R. H. Swendsen, P. A. Kollman, and J. M. Rosenberg, \nJ. Comput. Chem. 13, 1011 (1992).\n\n\n\n\n\n","category":"method"}]
}
