<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Structural computations · MDToolbox.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MDToolbox.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">MDToolbox.jl</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><span class="tocitem">Getting started</span><ul><li><a class="tocitem" href="../getting_started01/">Input and Output</a></li><li><a class="tocitem" href="../getting_started02/">TrjArray type</a></li><li><a class="tocitem" href="../getting_started03/">Atom selection</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../superimpose_rmsd/">Superimpose and RMSD</a></li><li><a class="tocitem" href="../free_energy_surface/">Free energy surface from MD data</a></li><li><a class="tocitem" href="../wham_example/">WHAM (Weighted Histogram Analysis Method)</a></li></ul></li><li><span class="tocitem">References</span><ul><li><a class="tocitem" href="../fileio/">File IO</a></li><li class="is-active"><a class="tocitem" href>Structural computations</a></li><li><a class="tocitem" href="../reduction/">Reductions</a></li><li><a class="tocitem" href="../wham/">WHAM (Weighted Histogram Analysis Method)</a></li><li><a class="tocitem" href="../mbar/">MBAR (Multistate Bennett acceptance ratio)</a></li><li><a class="tocitem" href="../msm/">Makorv state models</a></li></ul></li><li><a class="tocitem" href="../workflow_for_developers/">Workflow for developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">References</a></li><li class="is-active"><a href>Structural computations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Structural computations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/matsunagalab/MDToolbox.jl/blob/master/docs/src/structure.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Structural-computations"><a class="docs-heading-anchor" href="#Structural-computations">Structural computations</a><a id="Structural-computations-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-computations" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.centerofmass-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.centerofmass-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.centerofmass</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">centerofmass(ta::TrjArray; isweight=true, index::Union{UnitRange,Vector,BitArray}) -&gt; com::TrjArray</code></pre><p>Calculates the center of mass coordinates (COM) of the given trajectory, a <code>TrjArray</code> object <code>ta</code>.  If <code>isweight</code> is <code>true</code> (default), coordinates are weighted by <code>ta.mass</code> (as long as <code>ta.mass</code> is not empty). Uses can also specify column indices for the COM calculation by giving <code>index</code> which should be a Vector of integers, a UnitRange, or a BiArray. </p><p>Returns the center of mass coordinates as a TrjArray object, which have virtual single &quot;atom&quot; whose coordinates are COMs. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; com = centersofmass(ta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L36-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.decenter-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.decenter-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.decenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decenter(ta::TrjArray; isweight=true, index::Union{UnitRange,Vector,BitArray}) -&gt; ta_decentered::TrjArray, com::TrjArray</code></pre><p>Calculates the centers of mass coordinates (COM) of the given trajectory, a TrjArray object ta. And translates the coordinates so that the COM of the output is identical to the origin (x=y=z=0).  If <code>isweight</code> is <code>true</code> (default), coordinates are weighted by <code>ta.mass</code> (as long as <code>ta.mass</code> is not empty). Uses can also specify column indices for the COM calculation by giving <code>index</code> which should be a Vector of integers, a UnitRange, or a BiArray. </p><p>Returns a TrjArray object whose COM is the origin (x=y=z=0), and the COM of the given TrjArray <code>ta</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; ta_decentered = decenter(ta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L85-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.decenter!-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.decenter!-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.decenter!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decenter!(ta::TrjArray; isweight=true, index::Union{UnitRange,Vector,BitArray}) -&gt; com::TrjArray</code></pre><p>Translates the coordinates of the given trajectory, a TrjArray <code>ta</code>,  so that the COM of it become identical to the origin (x=y=z=0).  If <code>isweight</code> is <code>true</code> (default), coordinates are weighted by <code>ta.mass</code> (as long as <code>ta.mass</code> is not empty). Uses can also specify column indices for the COM calculation by giving <code>index</code> which should be an Array of integers. </p><p>Returns the center of mass coordinates of the given trajectory. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; decenter!(ta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L111-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.orient!-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.orient!-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.orient!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orient!(ta::TrjArray, index::Union{UnitRange,Vector,BitArray})</code></pre><p>Orient the molecule using its principal axes of inertia. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; orient!(ta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.rotate-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractVector{T}}} where {T, U}" href="#MDToolbox.rotate-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractVector{T}}} where {T, U}"><code>MDToolbox.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate(ta::TrjArray, quaternion::Vector) -&gt; ta_rotated::TrjArray</code></pre><p>Performs rotation of coordinates of the given TrjArray object <code>ta</code>.  Rotation matrix is constructed fromt the given <code>quaternion</code> vector. </p><p>Returns the trajecotry with rotated coordinates.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.dcd&quot;)
julia&gt; quaternion = [0.80951112,  0.10657412,  0.35146912,  0.45804312]
julia&gt; ta_rotated = rotate(ta, quaternion)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L456-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.rotate!-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractVector{T}}} where {T, U}" href="#MDToolbox.rotate!-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractVector{T}}} where {T, U}"><code>MDToolbox.rotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate!(ta::TrjArray, quaternion::Vector)</code></pre><p>Performs rotation of coordinates of the given TrjArray object <code>ta</code>.  Rotation matrix is constructed fromt the given <code>quaternion</code> vector. </p><p>The coordinates of <code>ta</code> is replaced with the rotated ones. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.dcd&quot;)
julia&gt; quaternion = [0.80951112,  0.10657412,  0.35146912,  0.45804312]
julia&gt; rotate!(ta, quaternion)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L492-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.rotate-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractMatrix{T}}} where {T, U}" href="#MDToolbox.rotate-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractMatrix{T}}} where {T, U}"><code>MDToolbox.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate(ta::TrjArray, quaternions::Matrix) -&gt; ta_rotated::TrjArray</code></pre><p>Performs multiple rotations of the coordinates of the 1st frame of the given TrjArray object <code>ta</code>.  Rotation matrices are construcuted from the 2-dimensional Array <code>quaternions</code>. One set of quaternions for rotaton should be given in a row vector in <code>quaternions</code>. </p><p>Returns the trajecotry with rotated coordinates from the 1st frame of <code>ta</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; quaternions = [0.80951112  0.10657412  0.35146912  0.45804312; 
&gt;                     0.10657412  0.80951112  -0.35146912  0.45804312]
julia&gt; ta_rotated = rotate(ta, quaternions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L527-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.rotate_with_matrix-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractMatrix{T}}} where {T, U}" href="#MDToolbox.rotate_with_matrix-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, AbstractMatrix{T}}} where {T, U}"><code>MDToolbox.rotate_with_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate_with_matrix(ta::TrjArray, R::Matrix) -&gt; ta_rotated::TrjArray</code></pre><p>Performs rotation of coordinates of the given TrjArray object <code>ta</code> with the given rotation matrix. </p><p>The coordinates of <code>ta</code> is replaced with the rotated ones. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.dcd&quot;)
julia&gt; R = [0.36 0.48 -0.8;
            -0.8 0.60 0.0;
            -.48 0.64 0.60]
julia&gt; ra_rotated = rotate(ta, R)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L565-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.superimpose-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}} where {T, U}" href="#MDToolbox.superimpose-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}} where {T, U}"><code>MDToolbox.superimpose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">superimpose(ref::TrjArray, ta::TrjArray; isweight=true, index::Union{UnitRange,Vector,BitArray}, isdecenter=false) -&gt; ta_superimposed::TrjArray</code></pre><p>Performs the least-squares fitting of the given trajectory (TrjArray object <code>ta</code>)  to the reference structure (1st frame of TrjArray object <code>ref</code>).  If <code>isweight</code> is <code>true</code> (default), coordinates are weighted by <code>ta.mass</code> (as long as <code>ta.mass</code> is not empty). Uses can specify column indices for the COM calculation by giving <code>index</code> which should be a Vector of integers, a UnitRange, or a BiArray.  When <code>isdecenter</code> is <code>true</code>, the function assumes the COMs of both structures are located at the origin (default is <code>isdecenter=false</code>). </p><p>Returns the superimposed trajecotry. </p><p>The code of this function is licensed under the BSD license (Copyright (c) 2009-2016 Pu Liu and Douglas L. Theobald), see LICENSE.md</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ref = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=pdb)
julia&gt; ta_superimposed = superimpose(ref, ta)</code></pre><p><strong>References</strong></p><pre><code class="language-none">The algorithm of this function is based on 
P. Liu, D. K. Agrafiotis, and D. L. Theobald, 
J. Comput. Chem. 31, 1561-1563 (2010).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L592-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_rmsd-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}} where {T, U}" href="#MDToolbox.compute_rmsd-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}} where {T, U}"><code>MDToolbox.compute_rmsd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_rmsd(ref::TrjArray, ta::TrjArray; isweight=true, index=index::Union{UnitRange,Vector,BitArray}) -&gt; rmsd</code></pre><p>Calculates the root mean square deviations (RMSD) of the given trajectory (TrjArray object <code>ta</code>) from the reference structure (1st frame of TrjArray object <code>ref</code>).  If <code>isweight</code> is <code>true</code> (default), coordinates are weighted by <code>ta.mass</code> (as long as <code>ta.mass</code> is not empty). Uses can specify column indices for the RMSD calculation by giving <code>index</code> which should be a Vector of integers, a UnitRange, or a BiArray. </p><p>Returns RMSD values. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ref = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.nc&quot;, top=pdb)
julia&gt; ta_superimposed = superimpose(ref, ta)
julia&gt; rmsd = compute_rmsd(ref, ta_superimposed)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L765-L782">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.meanstructure-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.meanstructure-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.meanstructure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meanstructure(ta::TrjArray; isweight=true, index=index::Union{UnitRange,Vector,BitArray}) -&gt; ta_mean::TrjArray, ta_superimposed::TrjArray</code></pre><p>Calculates the mean structure of the given trajectory (TrjArray object <code>ta</code>) by iteratively fitting the trajecotry to tentative mean structures until the mean structure converges.  If <code>isweight</code> is <code>true</code> (default), coordinates are weighted by <code>ta.mass</code> (as long as <code>ta.mass</code> is not empty). Uses can specify column indices for the fitting (superimpose function) by giving <code>index</code> which should be a Vector of integers, a UnitRange, or a BiArray. </p><p>Returns the mean structure as TrjArray object, and the supserimposed trajectory to the mean structure. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.nc&quot;, top=pdb)
julia&gt; ta_mean, ta_superimposed = meanstructure(ta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L806-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_rmsf-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.compute_rmsf-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.compute_rmsf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_rmsf(ta::TrjArray{T, U}; isweight::Bool=true) -&gt; rmsf</code></pre><p>rmsf (root mean square fluctuation)</p><p>Calculates the root mean square fluctuations (RMSFs) of the atoms in the given trajectory (TrjArray object <code>ta</code>).  from the average coordinates of the trajectory.  If <code>isweight</code> is <code>true</code> (default), coordinates are weighted by <code>ta.mass</code> (as long as <code>ta.mass</code> is not empty).</p><p>Returns RMSF values. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.nc&quot;, top=pdb)
julia&gt; ta_mean, ta_superimposed = meanstructure(ta)
julia&gt; rmsf = compute_rmsf(ta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L843-L860">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_distance-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, Any}} where {T, U}" href="#MDToolbox.compute_distance-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, Any}} where {T, U}"><code>MDToolbox.compute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_distance(ta::TrjArray, index::Matrix)</code></pre><p>Calculates distances between two atom pairs specified by the Matrix object <code>index</code>.  Each row vector in <code>index</code> contains two column indices for calculating distance.  Default of <code>index</code> is <code>[1 2]</code>. </p><p>Returns distances specified pairs in <code>index</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.dcd&quot;)
julia&gt; d = compute_distance(ta, [1 2; 1; 3])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L885-L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_distance-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}, Tuple{TrjArray{T, U}, TrjArray{T, U}, Any}} where {T, U}" href="#MDToolbox.compute_distance-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}, Tuple{TrjArray{T, U}, TrjArray{T, U}, Any}} where {T, U}"><code>MDToolbox.compute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_distance(ta1::TrjArray, ta2::TrjArray, index::Matrix)</code></pre><p>Calculates distances between two atom pairs in <code>ta1</code> and <code>ta2</code> specified by the Matrix object <code>index</code>.  Each row vector in <code>index</code> contains a column index of <code>ta1</code> and column index of <code>ta2</code> for calculating distance.  Default of <code>index</code> is <code>[1 1]</code>. </p><p>Returns distances specified pairs in <code>index</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=ta)
julia&gt; d = compute_distance(ta[:, &quot;atomid 1&quot;], ta[:, &quot;atomid 9&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L915-L930">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_distancemap-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.compute_distancemap-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.compute_distancemap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_distancemap(ta::TrjArray; kneighbor=3)</code></pre><p>Calculates distance-map vectors from the given TrjArray <code>ta</code>.  If <code>atomid=j</code> and <code>atomid=i</code> are closer to each other than the specified <code>kneighbor</code>, i.e., <code>abs(i-j) &lt; kneighbor</code>,  the calculation of the distance is ignored, considering that they are not nonbonded pairs.  The default value of <code>kneighbor</code> is <code>3</code>. </p><p>Returns distance-map vectors of all frames. The distance-map of each frame is contained in a row vector of the output.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=ta)
julia&gt; d = compute_distancemap(ta[&quot;atomname CA&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L946-L962">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_contactmap-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}" href="#MDToolbox.compute_contactmap-Union{Tuple{TrjArray{T, U}}, Tuple{U}, Tuple{T}} where {T, U}"><code>MDToolbox.compute_contactmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_contactmap(ta::TrjArray; rcut=8.5, kneighbor=3)</code></pre><p>Calculates contact-map vectors from the given TrjArray <code>ta</code>.  Cut-off value for contact can be given in <code>rcut</code> (default is <code>rcut=8.5</code>).  If <code>atomid=j</code> and <code>atomid=i</code> are closer to each other than the specified <code>kneighbor</code>, i.e., <code>abs(i-j) &lt; kneighbor</code>,  the calculation of the distance is ignored, considering that they are not nonbonded pairs.  The default value of <code>kneighbor</code> is <code>3</code>. </p><p>Returns contact-map vectors of all frames. The contact-map of each frame is contained in a row vector of the output. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=ta)
julia&gt; d = compute_distancemap(ta[&quot;atomname CA&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L985-L1002">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_angle-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}, TrjArray{T, U}}} where {T, U}" href="#MDToolbox.compute_angle-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}, TrjArray{T, U}}} where {T, U}"><code>MDToolbox.compute_angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_angle(ta1::TrjArray, ta2::TrjArray, ta3::TrjArray)</code></pre><p>Calculates angles for the atom coordinates or the COMs of groups from the triplet of <code>ta1</code>, <code>ta2</code> and <code>ta3</code>. </p><p>Returns angles.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=ta)
julia&gt; a = compute_distance(ta[:, &quot;atomid 1&quot;], ta[:, &quot;atomid 9&quot;], ta[:, &quot;atomid 11&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L1009-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_dihedral-Union{Tuple{U}, Tuple{T}, NTuple{4, TrjArray{T, U}}} where {T, U}" href="#MDToolbox.compute_dihedral-Union{Tuple{U}, Tuple{T}, NTuple{4, TrjArray{T, U}}} where {T, U}"><code>MDToolbox.compute_dihedral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_dihedral(ta1::TrjArray, ta2::TrjArray, ta3::TrjArray, ta4::TrjArray)</code></pre><p>Calculates dihedral angles for the atom coordinates or the COMs of groups from the quadruplet of <code>ta1</code>, <code>ta2</code>, <code>ta3</code> and <code>ta4</code>. </p><p>Returns dihedral angles.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=ta)
julia&gt; d = compute_dihedral(ta[:, &quot;atomid 1&quot;], ta[:, &quot;atomid 9&quot;], ta[:, &quot;atomid 11&quot;, ta[:, &quot;atom 13&quot;]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L1037-L1050">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_dihedral-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, Any}} where {T, U}" href="#MDToolbox.compute_dihedral-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, Any}} where {T, U}"><code>MDToolbox.compute_dihedral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_dihedral(ta1::TrjArray, ta2::TrjArray, ta3::TrjArray, ta4::TrjArray)</code></pre><p>Calculates dihedral angles for the atom coordinates or the COMs of groups from the quadruplet of <code>ta1</code>, <code>ta2</code>, <code>ta3</code> and <code>ta4</code>. </p><p>Returns dihedral angles.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=ta)
julia&gt; d = compute_dihedral(ta[:, &quot;atomid 1&quot;], ta[:, &quot;atomid 9&quot;], ta[:, &quot;atomid 11&quot;, ta[:, &quot;atom 13&quot;]])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L1074-L1087">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_qscore-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}} where {T, U}" href="#MDToolbox.compute_qscore-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, TrjArray{T, U}}} where {T, U}"><code>MDToolbox.compute_qscore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_qscore(native::TrjArray, ta::TrjArray) -&gt; qscore::Array</code></pre><p>Calculates all-atom based Q-score from given heavy atom coordinates. </p><p>Returns Q-scores. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; native = mdload(&quot;ak.pdb&quot;)
julia&gt; ta = mdload(&quot;ak.dcd&quot;, top=native)
julia&gt; qscore = compute_qscore(native[&quot;not hydrogen&quot;], ta[&quot;not hydrogen&quot;])</code></pre><p><strong>References</strong></p><pre><code class="language-none">Definition of Q-score from heavy atoms is given in 
R. B. Best, G. Hummer, and W. A. Eaton, PNAS 110, 17874 (2013).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L1118-L1137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_drms-Union{Tuple{U}, Tuple{T}, NTuple{4, TrjArray{T, U}}} where {T, U}" href="#MDToolbox.compute_drms-Union{Tuple{U}, Tuple{T}, NTuple{4, TrjArray{T, U}}} where {T, U}"><code>MDToolbox.compute_drms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_drms(native1::TrjArray, native2::TrjArray, ta1::TrjArray, ta2::TrjArray) -&gt; drms</code></pre><p>Calculates distance-based root mean square displacements (DRMS) from the given trajectories.  First, native contacts between molecule1 and molecule2 are identified from the two native structures <code>native1</code> and <code>native2</code> where cutoff distance of 6.0 Angstrom is used.  Then, the DRMS are calculated from the trajectories of molecule1 <code>ta1</code> and molecule2 <code>ta2</code>. </p><p>Returns distance-based root mean square displacements. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; native1 = mdload(&quot;protein.pdb&quot;)[&quot;not hydrogen&quot;]
julia&gt; native2 = mdload(&quot;ligand.pdb&quot;)[&quot;not hydrogen&quot;]
julia&gt; ta1 = mdload(&quot;protein.dcd&quot;)[&quot;not hydrogen&quot;]
julia&gt; ta2 = mdload(&quot;ligand.dcd&quot;)[&quot;not hydrogen&quot;]
julia&gt; drms = compute_drms(native1, native2, ta1, ta2)</code></pre><p><strong>References</strong></p><pre><code class="language-none">Definition of DRMS is given in 
J. Domański, G. Hedger, R. B. Best, P. J. Stansfeld, and M. S. P. Sansom, 
Convergence and Sampling in Determining Free Energy Landscapes for Membrane Protein Association, 
J. Phys. Chem. B 121, 3364 (2017).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L1164-L1189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_pairlist-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, T}} where {T, U}" href="#MDToolbox.compute_pairlist-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, T}} where {T, U}"><code>MDToolbox.compute_pairlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_pairlist(ta::TrjArray, rcut; iframe=1::Int) -&gt; F</code></pre><p>Make a pairlist for the given strcuture <code>ta1</code> by searching pairs within a cutoff distance <code>rcut</code>.  By default, the 1st frame of <code>ta1</code> is used. Users can specify the frame by <code>iframe</code>. </p><p>Returns a NamedTuple object <code>F</code> which contains the pair lists in <code>F.pair</code>,  and the distances of corresponding pairs in <code>F.dist</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; F = compute_pairlist(ta, 8.0)</code></pre><p><strong>References</strong></p><pre><code class="language-none">The algorithm of this function is based on 
T.N. Heinz, and P.H. Hünenberger, 
A fast pairlist-construction algorithm for molecular simulations under periodic boundary conditions. 
J Comput Chem 25, 1474–1486 (2004). </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L1322-L1344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MDToolbox.compute_pairlist_bruteforce-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, T}} where {T, U}" href="#MDToolbox.compute_pairlist_bruteforce-Union{Tuple{U}, Tuple{T}, Tuple{TrjArray{T, U}, T}} where {T, U}"><code>MDToolbox.compute_pairlist_bruteforce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_pairlist_bruteforce(ta::TrjArray, rcut; iframe=1::Int) -&gt; F</code></pre><p>Bruteforce search version of <code>compute_pairlist</code> function. Mainly used for debugging. </p><p>Returns a NamedTuple object <code>F</code> which contains the pair lists in <code>F.pair</code>,  and the distances of corresponding pairs in <code>F.dist</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ta = mdload(&quot;ak.pdb&quot;)
julia&gt; F = compute_pairlist(ta, 8.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/matsunagalab/MDToolbox.jl/blob/d96b78322f7cc542ff164d790dfc5c0c3e85fed6/src/structure.jl#L1465-L1478">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fileio/">« File IO</a><a class="docs-footer-nextpage" href="../reduction/">Reductions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 29 January 2022 01:33">Saturday 29 January 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
